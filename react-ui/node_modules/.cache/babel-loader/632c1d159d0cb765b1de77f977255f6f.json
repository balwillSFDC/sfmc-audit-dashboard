{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/* Copyright (c) 2015-present, salesforce.com, inc. All rights reserved */\n\n/* Licensed under BSD 3-Clause - see LICENSE.txt or git.io/sfdc-license */\n\n\nimport ReactDOM from 'react-dom';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport KEYS from './key-code';\n\nvar keyboardNavigate = function keyboardNavigate(_ref) {\n  var componentContext = _ref.componentContext,\n      currentFocusedIndex = _ref.currentFocusedIndex,\n      isOpen = _ref.isOpen,\n      event = _ref.event,\n      key = _ref.key,\n      keyCode = _ref.keyCode,\n      navigableItems = _ref.navigableItems,\n      onFocus = _ref.onFocus,\n      onSelect = _ref.onSelect,\n      target = _ref.target,\n      toggleOpen = _ref.toggleOpen;\n  var indexes = navigableItems.indexes;\n  var lastIndex = indexes.length - 1;\n  var focusedIndex;\n  var ch = key || String.fromCharCode(keyCode);\n\n  if (/^[ -~]$/.test(ch)) {\n    ch = ch.toLowerCase();\n  } else {\n    ch = null;\n  }\n\n  var openMenuKeys = keyCode === KEYS.ENTER || keyCode === KEYS.SPACE || keyCode === KEYS.UP;\n\n  if (keyCode === KEYS.ESCAPE) {\n    if (isOpen) toggleOpen();\n  } else if (!isOpen) {\n    var _indexes = _slicedToArray(indexes, 1);\n\n    focusedIndex = _indexes[0];\n\n    if (openMenuKeys || ch) {\n      toggleOpen();\n    }\n\n    if (openMenuKeys && componentContext.trigger && // eslint-disable-next-line react/no-find-dom-node\n    ReactDOM.findDOMNode(componentContext.trigger) === target) {\n      componentContext.handleClick(event);\n    }\n  } else if (keyCode === KEYS.ENTER || keyCode === KEYS.SPACE) {\n    onSelect(currentFocusedIndex);\n  } else {\n    var navigableIndex = indexes.indexOf(currentFocusedIndex);\n\n    if (keyCode === KEYS.DOWN) {\n      if (navigableIndex < lastIndex) {\n        var newNavigableIndex = navigableIndex + 1;\n        focusedIndex = indexes[newNavigableIndex];\n      } else {\n        var _indexes2 = _slicedToArray(indexes, 1);\n\n        focusedIndex = _indexes2[0];\n      }\n    } else if (keyCode === KEYS.UP) {\n      if (navigableIndex > 0) {\n        var _newNavigableIndex = navigableIndex - 1;\n\n        focusedIndex = indexes[_newNavigableIndex];\n      } else {\n        focusedIndex = indexes[lastIndex];\n      }\n    } else if (ch) {\n      // Combine subsequent keypresses\n      var pattern = navigableItems.keyBuffer(ch);\n      var consecutive = 0; // Support for navigating to the next option of the same letter with repeated presses of the same key\n\n      if (pattern.length > 1 && new RegExp(\"^[\".concat(escapeRegExp(ch), \"]+$\")).test(pattern)) {\n        consecutive = pattern.length;\n      }\n\n      navigableItems.forEach(function (item) {\n        if (focusedIndex === undefined && item.text.substr(0, pattern.length) === pattern || consecutive > 0 && item.text.substr(0, 1) === ch) {\n          consecutive -= 1;\n          focusedIndex = item.index;\n        }\n      });\n    }\n  }\n\n  onFocus(focusedIndex);\n  return focusedIndex;\n};\n\nexport default keyboardNavigate;","map":{"version":3,"sources":["../../.tmp-es/utilities/keyboard-navigate.js"],"names":["keyboardNavigate","componentContext","currentFocusedIndex","isOpen","event","key","keyCode","navigableItems","onFocus","onSelect","target","toggleOpen","indexes","lastIndex","ch","String","openMenuKeys","KEYS","focusedIndex","ReactDOM","navigableIndex","newNavigableIndex","pattern","consecutive","escapeRegExp","item"],"mappings":"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","sourcesContent":["/* Copyright (c) 2015-present, salesforce.com, inc. All rights reserved */\n/* Licensed under BSD 3-Clause - see LICENSE.txt or git.io/sfdc-license */\nimport ReactDOM from 'react-dom';\nimport escapeRegExp from 'lodash.escaperegexp';\n\nimport KEYS from './key-code';\n\nconst keyboardNavigate = ({\n\tcomponentContext,\n\tcurrentFocusedIndex,\n\tisOpen,\n\tevent,\n\tkey,\n\tkeyCode,\n\tnavigableItems,\n\tonFocus,\n\tonSelect,\n\ttarget,\n\ttoggleOpen,\n}) => {\n\tconst { indexes } = navigableItems;\n\tconst lastIndex = indexes.length - 1;\n\tlet focusedIndex;\n\tlet ch = key || String.fromCharCode(keyCode);\n\n\tif (/^[ -~]$/.test(ch)) {\n\t\tch = ch.toLowerCase();\n\t} else {\n\t\tch = null;\n\t}\n\n\tconst openMenuKeys =\n\t\tkeyCode === KEYS.ENTER || keyCode === KEYS.SPACE || keyCode === KEYS.UP;\n\n\tif (keyCode === KEYS.ESCAPE) {\n\t\tif (isOpen) toggleOpen();\n\t} else if (!isOpen) {\n\t\t[focusedIndex] = indexes;\n\t\tif (openMenuKeys || ch) {\n\t\t\ttoggleOpen();\n\t\t}\n\t\tif (\n\t\t\topenMenuKeys &&\n\t\t\tcomponentContext.trigger &&\n\t\t\t// eslint-disable-next-line react/no-find-dom-node\n\t\t\tReactDOM.findDOMNode(componentContext.trigger) === target\n\t\t) {\n\t\t\tcomponentContext.handleClick(event);\n\t\t}\n\t} else if (keyCode === KEYS.ENTER || keyCode === KEYS.SPACE) {\n\t\tonSelect(currentFocusedIndex);\n\t} else {\n\t\tconst navigableIndex = indexes.indexOf(currentFocusedIndex);\n\n\t\tif (keyCode === KEYS.DOWN) {\n\t\t\tif (navigableIndex < lastIndex) {\n\t\t\t\tconst newNavigableIndex = navigableIndex + 1;\n\t\t\t\tfocusedIndex = indexes[newNavigableIndex];\n\t\t\t} else {\n\t\t\t\t[focusedIndex] = indexes;\n\t\t\t}\n\t\t} else if (keyCode === KEYS.UP) {\n\t\t\tif (navigableIndex > 0) {\n\t\t\t\tconst newNavigableIndex = navigableIndex - 1;\n\t\t\t\tfocusedIndex = indexes[newNavigableIndex];\n\t\t\t} else {\n\t\t\t\tfocusedIndex = indexes[lastIndex];\n\t\t\t}\n\t\t} else if (ch) {\n\t\t\t// Combine subsequent keypresses\n\t\t\tconst pattern = navigableItems.keyBuffer(ch);\n\t\t\tlet consecutive = 0;\n\n\t\t\t// Support for navigating to the next option of the same letter with repeated presses of the same key\n\t\t\tif (\n\t\t\t\tpattern.length > 1 &&\n\t\t\t\tnew RegExp(`^[${escapeRegExp(ch)}]+$`).test(pattern)\n\t\t\t) {\n\t\t\t\tconsecutive = pattern.length;\n\t\t\t}\n\n\t\t\tnavigableItems.forEach((item) => {\n\t\t\t\tif (\n\t\t\t\t\t(focusedIndex === undefined &&\n\t\t\t\t\t\titem.text.substr(0, pattern.length) === pattern) ||\n\t\t\t\t\t(consecutive > 0 && item.text.substr(0, 1) === ch)\n\t\t\t\t) {\n\t\t\t\t\tconsecutive -= 1;\n\t\t\t\t\tfocusedIndex = item.index;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tonFocus(focusedIndex);\n\n\treturn focusedIndex;\n};\n\nexport default keyboardNavigate;\n"]},"metadata":{},"sourceType":"module"}