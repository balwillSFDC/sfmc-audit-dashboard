{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/* eslint-disable fp/no-mutating-methods */\n\n/* Copyright (c) 2015-present, salesforce.com, inc. All rights reserved */\n\n/* Licensed under BSD 3-Clause - see LICENSE.txt or git.io/sfdc-license */\n\n/**\n * This is a UX pattern recommendation for auto-complete search results that can contain multiple subheadings within the results. It inserts a subheading object based on `option.type === subheading.id` directly before a found option object and only inserts the subheading at the first occurence of that type of option.\n */\n\n\nvar addSubheadings = function addSubheadings(_ref) {\n  var _ref2;\n\n  var subheadings = _ref.subheadings,\n      filteredOptions = _ref.filteredOptions; // Let's not mutate things we don't own.\n\n  var subheadingsCopy = _toConsumableArray(subheadings);\n\n  var sortedOptions = {\n    noSubHeaderType: []\n  }; // populate an object with subheader ID as the keys\n\n  subheadingsCopy.forEach(function (subH) {\n    if (subH.id) {\n      sortedOptions[subH.id] = [subH];\n    }\n  }); // sort options into arrays using option type\n  // if option type and subheader ID are equal, add to array, if no option type, add to noSubHeaderType array\n\n  filteredOptions.forEach(function (option) {\n    if (sortedOptions[option.type]) {\n      sortedOptions[option.type].push(option);\n    } else {\n      sortedOptions.noSubHeaderType.push(option);\n    }\n  }); // get object values by dropping keys\n  // flatten and remove child arrays, so that we have one array\n  // `...` operates on each array item, not the array\n\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(Object.values(sortedOptions)));\n};\n\nexport default addSubheadings;","map":{"version":3,"sources":["../../../.tmp-es/components/combobox/add-subheadings.js"],"names":["addSubheadings","subheadings","filteredOptions","subheadingsCopy","sortedOptions","noSubHeaderType","subH","option","Object"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA;AACA;AACA;;;AAEA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAsC;AAAA,MAAA,KAAA;;AAAA,MAAnCC,WAAmC,GAAA,IAAA,CAAnCA,WAAmC;AAAA,MAAtBC,eAAsB,GAAA,IAAA,CAAtBA,eAAsB,CAAA,CAC5D;;AACA,MAAMC,eAAe,GAAA,kBAAA,CAArB,WAAqB,CAArB;;AACA,MAAMC,aAAa,GAAG;AAAEC,IAAAA,eAAe,EAAE;AAAnB,GAAtB,CAH4D,CAK5D;;AACAF,EAAAA,eAAe,CAAfA,OAAAA,CAAwB,UAAA,IAAA,EAAU;AACjC,QAAIG,IAAI,CAAR,EAAA,EAAa;AACZF,MAAAA,aAAa,CAACE,IAAI,CAAlBF,EAAa,CAAbA,GAAyB,CAAzBA,IAAyB,CAAzBA;AACA;AAT0D,GAM5DD,EAN4D,CAY5D;AACA;;AACAD,EAAAA,eAAe,CAAfA,OAAAA,CAAwB,UAAA,MAAA,EAAY;AACnC,QAAIE,aAAa,CAACG,MAAM,CAAxB,IAAiB,CAAjB,EAAgC;AAC/BH,MAAAA,aAAa,CAACG,MAAM,CAApBH,IAAa,CAAbA,CAAAA,IAAAA,CAAAA,MAAAA;AADD,KAAA,MAEO;AACNA,MAAAA,aAAa,CAAbA,eAAAA,CAAAA,IAAAA,CAAAA,MAAAA;AACA;AAnB0D,GAc5DF,EAd4D,CAsB5D;AACA;AACA;;AACA,SAAO,CAAA,KAAA,GAAA,EAAA,EAAA,MAAA,CAAA,KAAA,CAAA,KAAA,EAAA,kBAAA,CAAaM,MAAM,CAANA,MAAAA,CAApB,aAAoBA,CAAb,CAAA,CAAP;AAzBD,CAAA;;AA4BA,eAAA,cAAA","sourcesContent":["/* eslint-disable fp/no-mutating-methods */\n/* Copyright (c) 2015-present, salesforce.com, inc. All rights reserved */\n/* Licensed under BSD 3-Clause - see LICENSE.txt or git.io/sfdc-license */\n\n/**\n * This is a UX pattern recommendation for auto-complete search results that can contain multiple subheadings within the results. It inserts a subheading object based on `option.type === subheading.id` directly before a found option object and only inserts the subheading at the first occurence of that type of option.\n */\n\nconst addSubheadings = ({ subheadings, filteredOptions }) => {\n\t// Let's not mutate things we don't own.\n\tconst subheadingsCopy = [...subheadings];\n\tconst sortedOptions = { noSubHeaderType: [] };\n\n\t// populate an object with subheader ID as the keys\n\tsubheadingsCopy.forEach((subH) => {\n\t\tif (subH.id) {\n\t\t\tsortedOptions[subH.id] = [subH];\n\t\t}\n\t});\n\n\t// sort options into arrays using option type\n\t// if option type and subheader ID are equal, add to array, if no option type, add to noSubHeaderType array\n\tfilteredOptions.forEach((option) => {\n\t\tif (sortedOptions[option.type]) {\n\t\t\tsortedOptions[option.type].push(option);\n\t\t} else {\n\t\t\tsortedOptions.noSubHeaderType.push(option);\n\t\t}\n\t});\n\n\t// get object values by dropping keys\n\t// flatten and remove child arrays, so that we have one array\n\t// `...` operates on each array item, not the array\n\treturn [].concat(...Object.values(sortedOptions));\n};\n\nexport default addSubheadings;\n"]},"metadata":{},"sourceType":"module"}