{"ast":null,"code":"import findTabbableElement from './tabbable';\nimport KEYS from './key-code';\nimport { canUseDOM } from './execution-environment';\nvar ancestor = null;\nvar focusLaterElement = null;\n\nvar handleScopedKeyDown = function handleScopedKeyDown(event) {\n  if (!canUseDOM || !ancestor || event.keyCode !== KEYS.TAB) {\n    return;\n  }\n\n  var tabbableElements = findTabbableElement(ancestor);\n  var finalTabbable = tabbableElements[event.shiftKey ? 0 : tabbableElements.length - 1];\n  var leavingFinalTabbable = finalTabbable === document.activeElement || // handle immediate shift+tab after opening with mouse\n  ancestor === document.activeElement;\n  if (!leavingFinalTabbable) return;\n  event.preventDefault();\n  var target = tabbableElements[event.shiftKey ? tabbableElements.length - 1 : 0];\n  target.focus();\n}; // PUBLIC methods\n\n\nvar ElementFocus = {\n  focusAncestor: function focusAncestor(_ref) {\n    var isPortal = _ref.isPortal;\n\n    if (canUseDOM) {\n      // When a portal is used (that is attaching a separate React mount, such as with Popover) programatic focusing within that portal may cause the window to scroll down to the DOM insertion point at the end of `body`. The following prevents the scrolling from occuring.\n      if (isPortal) {\n        var offset = window.pageYOffset;\n        ancestor.focus({\n          preventScroll: true\n        });\n        window.scrollTo(window.pageXOffset, offset);\n      } else {\n        ancestor.focus();\n      }\n    }\n  },\n  hasOrAncestorHasFocus: function hasOrAncestorHasFocus() {\n    return canUseDOM && (document.activeElement === ancestor || ancestor.contains(document.activeElement));\n  },\n  returnFocusToStoredElement: function returnFocusToStoredElement() {\n    if (canUseDOM) {\n      try {\n        focusLaterElement.focus();\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.warn(\"You tried to return focus to \".concat(focusLaterElement, \" but it is not in the DOM anymore\"));\n      }\n\n      focusLaterElement = null;\n    }\n  },\n  setupScopedFocus: function setupScopedFocus(_ref2) {\n    var ancestorElement = _ref2.ancestorElement;\n    ancestor = ancestorElement;\n    window.addEventListener('keydown', handleScopedKeyDown, false);\n  },\n  storeActiveElement: function storeActiveElement() {\n    focusLaterElement = canUseDOM ? document.activeElement : null;\n  },\n  teardownScopedFocus: function teardownScopedFocus() {\n    ancestor = null;\n\n    if (canUseDOM) {\n      window.removeEventListener('keydown', handleScopedKeyDown);\n    }\n  }\n};\nexport default ElementFocus;","map":{"version":3,"sources":["../../.tmp-es/utilities/dom-element-focus.js"],"names":["ancestor","focusLaterElement","handleScopedKeyDown","event","KEYS","tabbableElements","findTabbableElement","finalTabbable","leavingFinalTabbable","document","target","ElementFocus","focusAncestor","isPortal","offset","window","preventScroll","hasOrAncestorHasFocus","canUseDOM","returnFocusToStoredElement","console","setupScopedFocus","ancestorElement","storeActiveElement","teardownScopedFocus"],"mappings":"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","sourcesContent":["import findTabbableElement from './tabbable';\nimport KEYS from './key-code';\nimport { canUseDOM } from './execution-environment';\n\nlet ancestor = null;\nlet focusLaterElement = null;\n\nconst handleScopedKeyDown = (event) => {\n\tif (!canUseDOM || !ancestor || event.keyCode !== KEYS.TAB) {\n\t\treturn;\n\t}\n\tconst tabbableElements = findTabbableElement(ancestor);\n\tconst finalTabbable =\n\t\ttabbableElements[event.shiftKey ? 0 : tabbableElements.length - 1];\n\tconst leavingFinalTabbable =\n\t\tfinalTabbable === document.activeElement ||\n\t\t// handle immediate shift+tab after opening with mouse\n\t\tancestor === document.activeElement;\n\tif (!leavingFinalTabbable) return;\n\tevent.preventDefault();\n\tconst target =\n\t\ttabbableElements[event.shiftKey ? tabbableElements.length - 1 : 0];\n\ttarget.focus();\n};\n\n// PUBLIC methods\n\nconst ElementFocus = {\n\tfocusAncestor: ({ isPortal }) => {\n\t\tif (canUseDOM) {\n\t\t\t// When a portal is used (that is attaching a separate React mount, such as with Popover) programatic focusing within that portal may cause the window to scroll down to the DOM insertion point at the end of `body`. The following prevents the scrolling from occuring.\n\t\t\tif (isPortal) {\n\t\t\t\tconst offset = window.pageYOffset;\n\t\t\t\tancestor.focus({ preventScroll: true });\n\t\t\t\twindow.scrollTo(window.pageXOffset, offset);\n\t\t\t} else {\n\t\t\t\tancestor.focus();\n\t\t\t}\n\t\t}\n\t},\n\thasOrAncestorHasFocus: () =>\n\t\tcanUseDOM &&\n\t\t(document.activeElement === ancestor ||\n\t\t\tancestor.contains(document.activeElement)),\n\treturnFocusToStoredElement: () => {\n\t\tif (canUseDOM) {\n\t\t\ttry {\n\t\t\t\tfocusLaterElement.focus();\n\t\t\t} catch (e) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`You tried to return focus to ${focusLaterElement} but it is not in the DOM anymore`\n\t\t\t\t);\n\t\t\t}\n\t\t\tfocusLaterElement = null;\n\t\t}\n\t},\n\tsetupScopedFocus: ({ ancestorElement }) => {\n\t\tancestor = ancestorElement;\n\t\twindow.addEventListener('keydown', handleScopedKeyDown, false);\n\t},\n\tstoreActiveElement: () => {\n\t\tfocusLaterElement = canUseDOM ? document.activeElement : null;\n\t},\n\tteardownScopedFocus: () => {\n\t\tancestor = null;\n\t\tif (canUseDOM) {\n\t\t\twindow.removeEventListener('keydown', handleScopedKeyDown);\n\t\t}\n\t},\n};\n\nexport default ElementFocus;\n"]},"metadata":{},"sourceType":"module"}